# **BitMap**

BitMap从字面的意思，很多人认为是位图，其实准确的来说，翻译成基于位的映射。

在所有具有性能优化的数据结构中，大家使用最多的就是 Hash 表，是的，在具有定位查找上具有 O(1) 的常量时间，多么的简洁优美。但是数据量大了，内存就不够了。

当然也可以使用类似外排序来解决问题的，由于要走 IO 所以时间上又不行。

所谓的 Bit-map 就是用一个 bit 位来标记某个元素对应的 Value， 而 Key 即是该元素。由于采用了 Bit 为单位来存储数据，因此在存储空间方面，可以大大节省。

其实如果你知道计数排序的话（算法导论中有一节讲过），你就会发现这个和计数排序很像。

#### **bitmap**应用

​       1）可进行数据的快速查找，判重，删除，一般来说数据范围是 int 的10倍以下。
​       2）去重数据而达到压缩数据

还可以用于爬虫系统中 url 去重、解决全组合问题。

**BitMap**应用：排序示例

假设我们要对 0-7 内的 5 个元素 (4,7,2,5,3) 排序（这里假设这些元素没有重复）。那么我们就可以采用 Bit-map 的方法来达到排序的目的。要表示 8 个数，我们就只需要 8 个 Bit（1Bytes），首先我们开辟 1Byte 的空间，将这些空间的所有 Bit 位都置为 0 (如下图：)

然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1（可以这样操作 `p+(i/8)|(0×01<<(i%8))` 当然了这里的操作涉及到 Big-ending 和 Little-ending 的情况，这里默认为 Big-ending。不过计算机一般是小端存储的，如intel。小端的话就是将倒数第5位置1）,因为是从零开始的，所以要把第五位置为一（如下图）：

![https://img-my.csdn.net/uploads/201208/13/1344854388_8094.jpg](file:///C:/Users/wz/AppData/Local/Temp/msohtmlclip1/01/clip_image001.jpg)

然后再处理第二个元素7，将第八位置为1，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态如下：

![https://img-my.csdn.net/uploads/201208/13/1344854408_4675.jpg](file:///C:/Users/wz/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

然后我们现在遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的。

**bitmap**排序复杂度分析：

Bitmap排序需要的时间复杂度和空间复杂度依赖于数据中**最大的数字**。

bitmap排序的时间复杂度不是O(N)的，而是取决于待排序数组中的最大值MAX，在实际应用上关系也不大，比如我开10个线程去读 byte 数组，那么复杂度为：O(Max/10)。也就是要是读取的，可以用多线程的方式去读取。时间复杂度方面也是 O(Max/n)，其中 Max 为 byte[] 数组的大小，n为线程大小。

空间复杂度应该就是 O(Max/8) bytes 吧

#### **BitMap**算法流程

假设需要排序或者查找的最大数 MAX=10000000（lz:这里MAX应该是最大的数而不是int数据的总数！），那么我们需要申请内存空间的大小为 int a[1 + MAX/32]。

其中：a[0]在内存中占32为可以对应十进制数0-31，依次类推： 
 bitmap表为： 
 a[0]--------->0-31 
 a[1]--------->32-63 
 a[2]--------->64-95 
 a[3]--------->96-127 
 ..........

![https://img-blog.csdn.net/20131004110444937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1anVueHh4eHg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast](file:///C:/Users/wz/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)

我们要把一个整数 N 映射到 Bit-Map 中去，首先要确定把这个 N Mapping 到哪一个数组元素中去，即确定映射元素的 index。我们用 int 类型的数组作为 map 的元素，这样我们就知道了一个元素能够表示的数字个数(这里是32)。于是 N/32 就可以知道我们需要映射的 key 了。所以余下来的那个 N%32 就是要映射到的位数。

**1.求十进制数对应在数组*a*中的下标**
 先由十进制数 n 转换为与 32 的余可转化为对应在数组 a 中的下标。

如十进制数 0-31，都应该对应在 a[0] 中，比如 n=24 ,那么 n/32=0，则 24 对应在数组 a 中的下标为0。又比如n=60，那么 n/32=1，则60对应在数组 a 中的下标为1，同理可以计算 0-N 在数组 a 中的下标。

`i = N>>K    % 结果就是 N/(2^K)`

Note: map的范围是[0，原数组最大的数对应的2的整次方数-1]。

**2.求十进制数对应数组元素a[i]在0-31中的位m**
 十进制数0-31就对应0-31，而32-63则对应也是0-31，即给定一个数n可以通过模32求得对应0-31中的数。

`m = n & ((1 << K) - 1)      %结果就是 n%(2^K)`

**3.利用移位0-31使得对应第m个bit位为1**

`如 a[i] 的第 m 位置1：a[i] = a[i] | (1<<m)`

如：将当前4对应的bit位置1的话，只需要1左移4位与B[0] | 即可。

![http://pic002.cnblogs.com/images/2012/214741/2012120714304050.jpg](file:///C:/Users/wz/AppData/Local/Temp/msohtmlclip1/01/clip_image005.jpg)

Note:  1 . p+(i/8)|(0×01<<(i%8)) 这样也可以？

​	    2 . 同理将int型变量a的第k位清0，即a=a&~(1<<k)

[编程珠玑]

#### **BitMap算法评价**

优点：
     \1. 运算效率高，不进行比较和移位；
     \2. 占用内存少，比如最大的数MAX=10000000；只需占用内存为MAX/8=1250000Byte=1.25M。
 缺点：
     \1. 所有的数据不能重复，即**不可对重复的数据进行排序**。（少量重复数据查找还是可以的，用2-bitmap）。

​    \2. 当数据类似（1，1000，10万）只有3个数据的时候，用 bitmap 时间复杂度和空间复杂度相当大，只有当**数据比较密集时**才有优势。



#### BitMap算法的拓展

Bloom filter可以看做是对bit-map的扩展。更大数据量的**有一定误差的用来判断映射是否重复的算法。**[[Bloom Filter布隆过滤器](http://blog.csdn.net/pipisorry/article/details/64127666)] 

#### 问题及应用实例

**1** .**使用位图法判断整形数组是否存在重复**
 判断集合中存在重复是常见编程任务之一，当集合中数据量比较大时我们通常希望少进行几次扫描，这时双重循环法就不可取了。
 位图法比较适合于这种情况，它的做法是按照集合中最大元素 max 创建一个长度为 max+1 的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上1，如遇到 5就给新数组的第六个元素置1，这样下次再遇到5想置位时发现新数组的第六个元素已经是1了，这说明这次的数据肯定和以前的数据存在着重复。这种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称**位图法**。它的运算次数最坏的情况为2N。如果已知数组的最大值即能事先给新数组定长的话效率还能提高一倍。

**2 .在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数**

解法一：将 bit-map 扩展一下，采用 **2-Bitmap**（每个数分配 2bit，00 表示不存在，01表示出现一次，10 表示多次，11无意义）进行，共需内存 2^32 * 2 bit=1 GB 内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。

或者我们不用2bit来进行表示，我们用两个 bit-map 即可模拟实现这个 2bit-map，都是一样的道理。

解法二：也可采用与第1题类似的方法，进行划分小文件的方法。然后**在小文件中找出不重复的整数**，并排序。然后再**进行归并**，注意去除重复的元素。

解法三：（lz）类似解法2，只是划分时按照快排 partition 一样划分，直到划分到每个块都可以放入内存中。

**2.1** **一个序列里除了一个元素，其他元素都会重复出现3次，设计一个时间复杂度与空间复杂度最低的算法，找出这个不重复的元素。**

**3**  **已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。**

8 位最多 99 999 999，大概需要 99 m 个bit，大概10几m字节的内存即可。 （可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要 99M 个Bit = 1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话）

lz觉得这个是应该用计数排序类似的算法吧，而不是bitmap?

**4** **给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？**

 解析：bitmap 算法就好办多了。申请512M的内存，一个bit位代表一个 unsigned int 值，读入40亿个数，设置相应的 bit 位；读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。

Note: unsigned int最大数为 2^32 - 1，所以需要 2^32 - 1 个位，也就是 (2^32 - 1) / 8 /10 ^ 9G = 0.5G 内存。

​    逆向思维优化：usinged int 只有接近43亿（unsigned int 最大值为232-1=4294967295，最大不超过43亿），所以可以用某种方式存没有出现过的 3 亿个数（使用数组 {大小为3亿中最大的数 / 8 bytes} 存储），如果出现在 3亿个数里面，说明不在40亿里面。3亿个数存储空间一般小于40亿个。（xx存储 4294967296 需要 512 MB， 存储294967296 只需要35.16MBxx）

**5 给定一个数组a，求所有和为SUM的两个数**

如果数组都是整数（负数也可以，将所有数据加上最小的负数 x，SUM += 2x 就可以了）。如 a = [1,2,3,4,7,8]，先求a的补数组[8,7,6,5,2,1]，开辟两个数组 b1,b2（最大数组长度为 SUM/8/2 {因为两数满足和为SUM，一个数<SUM/2，另一个数也就知道了}，这样每个b数组最大内存为  SUM/(8*2*1024*1024) = 128M），使用 bitmap算法和数组 a 分别设置 b1b2 对应的位为1，b1b2 相与就可以得到和为 SUM 的两个数其中一个数了。

![https://img-blog.csdn.net/20170317200156665?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGlwaXNvcnJ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center](file:///C:/Users/wz/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png)

**腾讯面试题：给20亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中并且所耗内存尽可能的少？**

 解析：bitmap算法就好办多了

 所谓bitmap，就是用每一位来存放某种状态，适用于大规模数据，但**数据状态又不是很多**的情况。通常是用来判断某个数据存不存在的。

 例如，要判断一千万个人的状态，每个人只有两种状态：男人，女人，可以用0，1表示。那么就可以开一个 int 数组，一个 int 有32个位，就可以表示 32 个人。操作的时候可以使用位操作。

一、申请 512M 的内存

1. 一个bit位代表一个 unsigned int 值
2. 读入20亿个数，设置相应的bit位
3. 读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在

二、使用位图法判断整形数组是否存在重复

判断集合中存在重复是常见编程任务之一，当集合中数据量比较大时我们通常希望少进行几次扫描，这时双重循环法就不可取了。

位图法比较适合于这种情况，它的做法是按照集合中最大元素max创建一个长度为 max+1 的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上1，如遇到 5 就给新数组的第六个元素置1，这样下次再遇到 5 想置位时发现新数组的第六个元素已经是 1 了，这说明这次的数据肯定和以前的数据存在着重复。这种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。它的运算次数最坏的情况为2N。如果已知数组的最大值即能事先给新数组定长的话效率还能提高一倍。

  java 代码实现  ：

```java
import java.util.BitSet;  

public class Bitmap {  

     byte[] tem;  

     public Bitmap(int length) {  

           this.tem = new byte[length];  

     }  
     

    public void add(int num) {  

       if (num < tem.length) {  

            if(tem[num] != 1) {  

               tem[num] = 1;  

            }  
       }  
   }  

\16.    

\17.   **public** **boolean** contain(**int** num) {  

\18.              **if** (num < tem.length) {  

\19.                   **if** (tem[num] == 1) {  

\20.                              **return** **true**;  

\21.                       }  

\22.               }  

\23.              **return** **false**;  

\24.   }  

\25.    

\26.   **public** **static** **void** main(String[] args) {  

\27.    /*运行前内存*/  

\28.               **long** beforeMemory = Runtime.getRuntime().totalMemory();  

\29.              **long** start1=System.currentTimeMillis();  

\30.              BitSet set = **new** BitSet(2000000000);  

\31.              **for** (**int** i = 0; i < 2000000000; i++) {  

\32.              /*假设898989这个数不在20亿个数里面*/  

\33.                        **if** (i != 898989) {  

\34.                              set.set(i, **true**);  

\35.                        }  

\36.               }  

\37.              /*创建20亿个数后所占内存*/  

\38.               **long** afterMemory = Runtime.getRuntime().totalMemory();  

\39.              **long** end1=System.currentTimeMillis();  

\40.               System.out.println("总共内存使用:" + (afterMemory - beforeMemory) / 1024 / 1024 + "MB");  

\41.              System.out.println("存入内存耗时:"+(end1-start1)+"毫秒");  

\42.              **long** start2 = System.currentTimeMillis();  

\43.               **boolean** isExit1=set.get(898989);  

\44.               **boolean** isExit2=set.get(900000);  

\45.     

\46.              **long** end2 = System.currentTimeMillis();  

\47.    /*输出在20亿个数中判断898989是否包含在里面*/  

\48.              System.out.println(isExit1);  

\49.              System.out.println("20个亿中"+(isExit1?"包含":"不包含")+898989);  

\50.               System.out.println("20个亿中"+(isExit2?"包含":"不包含")+900000);  

\51.               System.out.println("查询用时:"+(end2 - start2)+"毫秒");  

\52.              }  

\53.  }  
```



 